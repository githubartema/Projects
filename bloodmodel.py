# -*- coding: utf-8 -*-
"""bloodModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TTCShJ5zkh3XMCopB3mpbFwXnr4Rsgkt
"""

from google.colab import files
from PIL import Image
import numpy as np
from io import BytesIO
import matplotlib.pyplot as plt
import sys
import random
from scipy.optimize import curve_fit

def fit_func(x, a, b, k):
  return (k/(x + a) + b)

np.set_printoptions(threshold=sys.maxsize)

def reshaping(dataArray): 
  temporaryData = np.zeros((int(dataArray.shape[0]), int(dataArray.shape[1])))
  tempS = 0
  for i in range(int(dataArray.shape[0])):
    for j in range(int(dataArray.shape[1])):
      for _ in range(3):
        tempS = tempS + dataArray[i][j][_]
      temporaryData[i][j] = tempS // 765
      tempS = 0
  return temporaryData
    
def appr(y_values, n):
  sum_x = n*(n-1)/2
  sum_y = y_values.sum()
  sum_x_2 = n*(n-1)*(2*n-1)/6
  sum_xy = 0 
  for i in range(n):
    sum_xy += y_values[i]*(i)
  a = (n*sum_xy - sum_x*sum_y) / (n*sum_x_2 - sum_x**2)
  b = (sum_y - a*sum_x)/n
  return a,b


def length(x, y, x1, y1, count):
  return ((x - x1)**2 + (y - y1)**2)/count

data = np.ones((10000, 10000)) 

def pictureShow(choice):
  global data
  if choice == 1:
    uploaded = files.upload()
    image = Image.open(BytesIO(uploaded['example.bmp']))
    dataArray = reshaping(np.array(image)) 
    data = dataArray
  plt.imshow(data)
  plt.show()

  

def check():
  global data
  global traectory
  global x, y
  traectory [x][y] = 20
  res = [0, 0, 0, 0, 0, 0, 0, 0]
  diff = [[1, 0],
          [1, 1],
          [0, 1],
          [-1, 1],
          [-1, 0],
          [-1, -1],
          [0, -1],
          [1, -1]]

  for _ in range(8):
    if(_ % 2 == 0):
      if(data[x + diff[_][0]][y + diff[_][1]] == 1):
        res[_] = 1
    else:
      if(data[x + diff[_][0]][y + diff[_][1]] == 1 and (data[x + diff[_ - 1][0]][y + diff[_][1]] == 1 or 
                                                        data[x + diff[(_+1)%8][0]][y + diff[(_+1)%8][1]] == 1)):
        res[_] = 1
    
  t1 = []
  
  for i in range(8):
    if(res[i] == 1):
      t1.append(i)
  possible = random.choice(t1)
  x = x + diff[possible][0]
  y = y + diff[possible][1]

pictureShow(int(input()))

length_stat = np.zeros(100000)
traectory = np.zeros((int(data.shape[0]),int(data.shape[1])))

for _ in range(100):
  count = 0
  x, y = int(data.shape[0]/2), int(data.shape[1]/2)
  x_0, y_0 = x, y 
  for __ in range(100000):
    check()
    if (data.shape[0]<10000 and (x-272)**2 + (y-272)**2 == 258**2):
      break 
    count = count + 1
    length_stat[__]+=length(x_0, y_0, x, y, count)
    #print(x, y, data[x][y])
 
def traectoryDraw():
  global traectory
  plt.gcf().set_size_inches(20, 20)
  plt.imshow(traectory)
  plt.show()

def lineDraw(a, b, k):
  plt.plot([(k/(x+a) + b) for x in range(100000)])

traectoryDraw()
  
length_stat[:] = [x * (1/100) for x in length_stat]
times = [x for x in range(len(length_stat))]

Yy = np.asarray(length_stat)
Xx = np.asarray(times)

coeff = np.polyfit(Xx, Yy, 3)
polinom = np.poly1d(coeff)

polinom_curve = polinom(Xx)

[A, B, K] = curve_fit(fit_func, Xx, Yy)[0]

plt.plot(length_stat)
plt.plot(y_new)
lineDraw(A, B, K)